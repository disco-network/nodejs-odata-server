{"version":3,"sources":["src/odata/queries.ts"],"names":[],"mappings":"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","file":"src/odata/queries.js","sourcesContent":["/** @module */\nimport Schema = require(\"./schema\");\n\nexport interface Query {\n  run(sparqlProvider, cb: () => void): void;\n  sendResults(res): void;\n}\n\nexport interface QueryModel {\n  entitySetName: string;\n  path: any[]; /** navigation path */\n  filterOption: any;\n  expandTree: any;\n}\n\n/** This class can be used to generate odata output from different sources.\n * The concrete database logic is handled by the result and context parameters.\n */\nexport class QueryResultEvaluator {\n  // result type corresponds to what's needed by the context instance\n  public evaluate(results: any[], context: QueryContext): any[] {\n    let entities = {};\n\n    results.forEach(result => {\n      let id = context.getUniqueIdOfResult(result);\n      if (entities[id] === undefined) {\n        entities[id] = {};\n      }\n      context.forEachElementaryPropertyOfResult(result, (value, property) => {\n        this.assignElementaryProperty(entities[id], property, value);\n      });\n      context.forEachComplexPropertyOfResult(result, (subResult, property, hasValue) => {\n        if (hasValue)\n          this.assignComplexProperty(entities[id], property, subResult, context);\n      });\n    });\n\n    return Object.keys(entities).map(key => entities[key]);\n  }\n\n  private assignElementaryProperty(entity, property: Schema.Property, value) {\n    let oldValue = entity[property.getName()];\n    if (property.isQuantityOne()) {\n      if (oldValue !== undefined && value !== undefined && oldValue !== value)\n        throw new Error(\"found different values for a property of quantity one: \" + property.getName());\n      else\n        entity[property.getName()] = value;\n    }\n  }\n\n  private assignComplexProperty(entity, property: Schema.Property, result, context: QueryContext) {\n    let oldValue = entity[property.getName()];\n    if (property.isQuantityOne()) {\n      let subEntity;\n      if (oldValue !== undefined)\n        subEntity = oldValue;\n      else\n        subEntity = entity[property.getName()] = {};\n      let subContext = context.getSubContext(property.getName());\n      subContext.forEachElementaryPropertyOfResult(result, (subValue, subProperty) => {\n        this.assignElementaryProperty(subEntity, subProperty, subValue);\n      });\n      subContext.forEachComplexPropertyOfResult(result, (subResult, subProperty, hasValue) => {\n        if (hasValue)\n          this.assignComplexProperty(subEntity, subProperty, subResult, subContext);\n      });\n    }\n  }\n}\n\nexport interface QueryContext {\n  /** Iterate over all elementary properties expected by the query and pass their value. */\n  forEachElementaryPropertyOfResult(result, fn: (value, property: Schema.Property) => void): void;\n  /** Iterate over all complex properties expected by the query. */\n  forEachComplexPropertyOfResult(result, fn: (subResult, property: Schema.Property, hasValue: boolean) => void): void;\n  getUniqueIdOfResult(result): string;\n  getSubContext(property: string): QueryContext;\n}\n\nexport enum ErrorTypes {\n  NONE,\n  DB,\n  ENTITYSET_NOTFOUND,\n  PROPERTY_NOTFOUND,\n}\n"],"sourceRoot":"/source/"}