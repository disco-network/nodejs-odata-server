{"version":3,"sources":["src/adapter/sparql_graphpatterns.ts"],"names":[],"mappings":"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","file":"src/adapter/sparql_graphpatterns.js","sourcesContent":["/** @module */\nimport Mappings = require(\"./sparql_mappings\");\nimport Schema = require(\"../odata/schema\");\n\nexport class GraphPatternWithBranches {\n  private createTriple: (property: string, branch: TreeGraphPattern) => any[];\n  private branches: { [id: string]: TreeGraphPattern[] } = {};\n\n  constructor(createTriple: (property: string, branch: TreeGraphPattern) => any[]) {\n    this.createTriple = createTriple;\n  }\n\n  public branch(property: string): TreeGraphPattern[];\n  public branch(property: string, arg: TreeGraphPattern): TreeGraphPattern;\n  public branch(property: string, arg?): any {\n    switch (typeof arg) {\n      case \"undefined\":\n        return this.branches[property] || [];\n      case \"object\":\n        if (this.branches[property] !== undefined)\n          this.branches[property].push(arg);\n        else\n          this.branches[property] = [ arg as TreeGraphPattern ];\n        return arg;\n      default:\n        throw new Error(\"branch argument was specified but is no object\");\n    }\n  }\n\n  public getDirectTriples(): any[][] {\n    let triples: any[][] = [];\n    this.enumerateBranches((property, branch) => {\n        triples.push(this.createTriple(property, branch));\n    });\n    return triples;\n  }\n\n  public getBranchPatterns(): TreeGraphPattern[] {\n    let patterns: TreeGraphPattern[] = [];\n    this.enumerateBranches((property, branch) => patterns.push(branch));\n    return patterns;\n  }\n\n  public enumerateBranches(fn: (property: string, branch: TreeGraphPattern) => void) {\n    for (let property in this.branches) {\n      let branches = this.branches[property];\n      branches.forEach(branch => fn(property, branch));\n    }\n  }\n\n  public merge(other: GraphPatternWithBranches) {\n    other.enumerateBranches((property, branch) => {\n      this.branch(property, branch);\n    });\n  }\n}\n\n/**\n * Provides a SPARQL graph pattern whose triples are generated from a\n * property tree\n */\nexport class TreeGraphPattern {\n  private rootName: string;\n  private branchPattern: GraphPatternWithBranches;\n  private inverseBranchPattern: GraphPatternWithBranches;\n  private optionalBranchPattern: GraphPatternWithBranches;\n\n  private valueLeaves: { [id: string]: ValueLeaf[] } = { };\n  private unionPatterns: TreeGraphPattern[] = [ ];\n\n  constructor(rootName: string) {\n    let createTriple = (property: string, branch: TreeGraphPattern) => {\n      return [this.name(), property, branch.name()];\n    };\n\n    let createInverseTriple = (property: string, branch: TreeGraphPattern) => {\n      return [branch.name(), property, this.name()];\n    };\n\n    this.rootName = rootName;\n    this.branchPattern = new GraphPatternWithBranches(createTriple);\n    this.inverseBranchPattern = new GraphPatternWithBranches(createInverseTriple);\n    this.optionalBranchPattern = new GraphPatternWithBranches(createTriple);\n  }\n\n  /*public getTriples(): any[][] {\n    let triples: any[][] = [];\n    for (let property in this.valueLeaves) {\n      let leaves = this.valueLeaves[property];\n      leaves.forEach(leaf => {\n        triples.push([ this.name(), property, \"\\\"\" + leaf.value + \"\\\"\" ]);\n      });\n    }\n    for (let property in this.branches) {\n      let branches = this.branches[property];\n      branches.forEach(branch => {\n        triples.push([ this.name(), property, branch.name() ]);\n        triples.push.apply(triples, branch.getTriples());\n      });\n    }\n    for (let property in this.inverseBranches) {\n      let branches = this.inverseBranches[property];\n      branches.forEach(branch => {\n        triples.push([ branch.name(), property, this.name() ]);\n        triples.push.apply(triples, branch.getTriples());\n      });\n    }\n    return triples;\n  }*/\n\n  public getDirectTriples(): any[][] {\n    let triples: any[][] = [];\n\n    for (let property in this.valueLeaves) {\n      let leaves = this.valueLeaves[property];\n      leaves.forEach(leaf => {\n        triples.push([ this.name(), property, \"\\\"\" + leaf.value + \"\\\"\" ]);\n      });\n    }\n\n    triples.push.apply(triples, this.branchPattern.getDirectTriples());\n    triples.push.apply(triples, this.inverseBranchPattern.getDirectTriples());\n\n    return triples;\n  }\n\n  public getBranchPatterns(): TreeGraphPattern[] {\n    let branches: TreeGraphPattern[] = [];\n    branches.push.apply(branches, this.branchPattern.getBranchPatterns());\n    branches.push.apply(branches, this.inverseBranchPattern.getBranchPatterns());\n    return branches;\n  }\n\n  public getOptionalPatterns(): TreeGraphPattern[] {\n    let patterns = [];\n    this.optionalBranchPattern.enumerateBranches((property, branch) => {\n      let gp = new TreeGraphPattern(this.name());\n      gp.branch(property, branch);\n      patterns.push(gp);\n    });\n    return patterns;\n  }\n\n  public getUnionPatterns(): TreeGraphPattern[] {\n    return this.unionPatterns;\n  }\n\n  public name(): string {\n    return this.rootName;\n  }\n\n  public branch(property: string): TreeGraphPattern[];\n  public branch(property: string, arg: string): TreeGraphPattern;\n  public branch(property: string, arg: TreeGraphPattern): TreeGraphPattern;\n  public branch(property: string, arg: ValueLeaf): void;\n  public branch(property: string, arg?): any {\n    switch (typeof arg) {\n      case \"undefined\":\n      case \"object\":\n        if (arg instanceof ValueLeaf) {\n          if (this.valueLeaves[property] !== undefined)\n            this.valueLeaves[property].push(arg);\n          else\n            this.valueLeaves[property] = [ arg as ValueLeaf ];\n          return;\n        }\n        else\n          return this.branchPattern.branch(property, arg);\n      case \"string\":\n        let pat = new TreeGraphPattern(arg);\n        return this.branch(property, pat);\n      default:\n        throw new Error(\"branch argument is neither string nor TreeGraphPattern respective ValueLeaf\");\n    }\n  }\n\n  public inverseBranch(property: string): TreeGraphPattern[];\n  public inverseBranch(property: string, arg: string): TreeGraphPattern;\n  public inverseBranch(property: string, arg: TreeGraphPattern): TreeGraphPattern;\n  public inverseBranch(property: string, arg?): any {\n    switch (typeof arg) {\n      case \"undefined\":\n      case \"object\":\n        return this.inverseBranchPattern.branch(property, arg);\n      case \"string\":\n        let pat = new TreeGraphPattern(arg);\n        return this.inverseBranchPattern.branch(property, pat);\n      default:\n        throw new Error(\"branch argument is neither string nor object\");\n    }\n  }\n\n  public optionalBranch(property: string): TreeGraphPattern[];\n  public optionalBranch(property: string, arg: string): TreeGraphPattern;\n  public optionalBranch(property: string, arg: TreeGraphPattern): TreeGraphPattern;\n  public optionalBranch(property, arg?): any {\n    switch (typeof arg) {\n      case \"undefined\":\n      case \"object\":\n        return this.optionalBranchPattern.branch(property, arg);\n      case \"string\":\n        let pat = new TreeGraphPattern(arg);\n        return this.optionalBranchPattern.branch(property, pat);\n      default:\n        throw new Error(\"branch argument is neither string nor object\");\n    }\n  }\n\n  public newUnionPattern(pattern?: TreeGraphPattern): TreeGraphPattern {\n    pattern = pattern || new TreeGraphPattern(this.name());\n    this.unionPatterns.push(pattern);\n    return pattern;\n  }\n\n  public branchExists(property: string): boolean {\n    return this.branchPattern.branch(property).length > 0;\n  }\n\n  public merge(other: TreeGraphPattern): void {\n    if (this.rootName !== other.rootName) throw new Error(\"can\\'t merge trees with different roots\");\n    this.branchPattern.merge(other.branchPattern);\n    this.inverseBranchPattern.merge(other.inverseBranchPattern);\n    this.optionalBranchPattern.merge(other.optionalBranchPattern);\n    /* @todo unions */\n  }\n}\n\nexport class ValueLeaf {\n  public value: string;\n\n  constructor(value: string) {\n    this.value = value;\n  }\n}\n\n/**\n * Provides a SPARQL graph pattern involving all the direct and elementary\n * properties belonging to the OData entity type passed as schema.\n * Please separate the options like this: \"no-id-property|some-other-option\"\n */\nexport class DirectPropertiesGraphPattern extends TreeGraphPattern {\n  constructor(entityType: Schema.EntityType, mapping: Mappings.StructuredSparqlVariableMapping, options: string) {\n    let entityVariable: string = mapping.getVariable();\n    super(entityVariable);\n\n    let propertyNames = entityType.getPropertyNames();\n    let properties = propertyNames.map(p => entityType.getProperty(p));\n\n    for (let i = 0; i < properties.length; ++i) {\n      let property = properties[i];\n      let propertyName = property.getName();\n      if (propertyName === \"Id\" && options.indexOf(\"no-id-property\") >= 0) continue;\n      if (property.isNavigationProperty() === false) {\n        if (!property.mirroredFromProperty()) {\n          // TODO: optional\n          this.branch(property.getNamespacedUri(), mapping.getElementaryPropertyVariable(propertyName));\n        }\n        else {\n          let mirroringProperty = property.mirroredFromProperty();\n          let propertyValueVar = mapping.getComplexProperty(mirroringProperty.getName()).getVariable();\n          if (mirroringProperty.isOptional() === false) {\n            this\n              .branch(mirroringProperty.getNamespacedUri(), propertyValueVar)\n              .branch(\"disco:id\", mapping.getElementaryPropertyVariable(propertyName));\n          }\n          else {\n            this\n              .optionalBranch(mirroringProperty.getNamespacedUri(), propertyValueVar)\n              .branch(\"disco:id\", mapping.getElementaryPropertyVariable(propertyName));\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Provides a SPARQL graph pattern according to an entity type schema,\n * an expand tree and a StructuredSparqlVariableMapping so that it contains\n * all the data necessary for an OData $expand query.\n */\nexport class ExpandTreeGraphPattern extends TreeGraphPattern {\n  constructor(entityType: Schema.EntityType, expandTree, mapping: Mappings.StructuredSparqlVariableMapping) {\n    super(mapping.getVariable());\n\n    this.branch(entityType.getProperty(\"Id\").getNamespacedUri(), mapping.getElementaryPropertyVariable(\"Id\"));\n\n    let directPropertyPattern = new DirectPropertiesGraphPattern(entityType, mapping, \"no-id-property\");\n    this.newUnionPattern(directPropertyPattern);\n    Object.keys(expandTree).forEach(propertyName => {\n      let property = entityType.getProperty(propertyName);\n      let propertyType = property.getEntityType();\n      // Next recursion level\n      let gp = new ExpandTreeGraphPattern(propertyType, expandTree[propertyName],\n        mapping.getComplexProperty(propertyName));\n      if (!property.hasDirectRdfRepresentation()) {\n        let inverseProperty = property.getInverseProperty();\n        let unionPattern = this.newUnionPattern();\n        unionPattern.inverseBranch(inverseProperty.getNamespacedUri(), gp);\n      }\n      else {\n        this.newUnionPattern().branch(property.getNamespacedUri(), gp);\n      }\n    });\n  }\n}\n"],"sourceRoot":"/source/"}